\documentclass{article}
\usepackage[left=1in,right=1in,top=1in,bottom=1in]{geometry}
\usepackage[ruled,vlined,linesnumbered,lined,boxed,commentsnumbered]{algorithm2e}

\setlength\parindent{0pt}

\begin{document}

    \section{Introduction}
    \label{sec:Introduction}
        A table of frequently used symbols: \\ \\
        \begin{tabular}{cl}
            \textbf{Symbol} & \textbf{Representation} \\
            \hline
            g & the input graph \\
            v & the set of nodes in g \\
            e & the set of edges in g \\
            n & a node in v \\
            G & the constructed metagraph \\
            V & the set of metanodes in G \\
            E & the set of metaedges in G \\
            N & a metanode in V of the form $\{n_i:x_i\}$ where $n_i \in v$ and
            $x_i$ is the number of atoms at $n_i$\\
            \hline
        \end{tabular} \\

        Each $N \in V$ is composed of $i$ many nodes from $v$. A
        metanode takes the form $\{n_i:x_i\}$ where $n_i \in v$ and $x_i$ is
        the number of atoms at $n_i$. The $\sum_0^i x_i = k$ at any given $N$
        ensuring that all atoms are accounted for at each metanode

    \section{Algorithms}
    \label{sec:Algorithms}

        \begin{algorithm}
            \caption{ConstructMetaGraph}
            \KwIn{$g = (v, e)$: the input graph, $\{s,t\} \in v$: the start and
                target compounds, $k$: flow/number of atoms to conserve}
            \KwOut{$G = (V, E)$: the meta-graph}

            $MG \gets (MV = \emptyset, ME = \emptyset)$ \tcc{initialize new
                metagraph}

            $stack \gets$ initialize empty stack\;

            $start \gets \{s:k\}$ \tcc{Create a metanode with all $k$ atoms at
                the start compound}

            $V \gets V \cup start$ \tcc{Add the start state to the set of
                metanodes}

            $stack.push(start)$ \tcc{Add the start state to the stack to find
                its neighbors}

            $G \gets \textbf{PopulateMetaGraph}(G, stack, target)$ \tcc{Find
                neighboring metanodes to build $G$}

            \Return{G}
        \end{algorithm}

        \begin{algorithm}
            \caption{PopulateMetaGraph}
            \KwIn{$G=(V,E)$: the metagraph, $stack$: stack of metanodes that
                need to be explored, $target$: the metanode state with all $k$
                atoms at node $t$}
            \KwOut{$G=(V,E)$: metagraph with any newly found metanodes added in}

            \While{$|stack| > 0$}{
                $current \gets stack.pop()$ \tcc{Pop off a metanode to explore}
                \If{current = target}{
                    continue \tcc{If we've reached the target, no need to find
                        nbrs}
                }
                \Else{
                    $nbrCount \gets \textbf{IterativeFindMetaNbrs}(current)$\;
                    \If{nbrCount = 0 \textbf{and} current $\neq$ target}{
                        $G \gets \textbf{Prune}(current)$ \tcc{This metanode is
                        a terminus, so remove it from the metagraph}
                    }
                }
            }
            \Return{G}
        \end{algorithm}

        \begin{algorithm}
            \caption{IterativeFindMetaNbrs}
            \KwIn{$parent$: the metanode to find nbrs for}
            \KwOut{$G=(V,E)$: metagraph with any newly found metanodes added in}

            \For{$n \in N$ \tcc{Iterate for each node involved in the metanode
                    state}}{
            }

            for each inner node n in N, for inner nbr m, move 0 to xi flow.
            For each move, attempt to move the remaining flow at n to the remaining
            inner nbrs m. Then repeat for each n in N. Check if any of the
            newly generated states are valid and add them to MG and stack

        \end{algorithm}


\end{document}
